<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="utf-8">


	<link rel="stylesheet" href="/css/article.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
	<title>OPF Programming - C++ Virtual Function In The Machine Level</title>
</head>

<body>
	<div class="main">
		<div class="article">
			<h1 class="top-title"><p>C++ Virtual Function In The Machine Level</p>
</h1>
			<div class="article-meta">
				<div class="article-date">2024-06-20T15:22:00+08:00</div>
				<div class="article-tags">C,C++,OOP,OPF Programming</div>
			</div>
			<p><a href="/articles/en/what-is-opf-programming.html"><code>OPF Programming</code></a>, or <code>(*p)-&gt;f(p)</code>, comes from the concept
of <code>Virtual Function</code> in C++.</p>
<p><code>OPF Programming</code> removes the fancy parts while keeping the core of
<code>Virtual Function</code>, which leads to a beautiful balance between practicality
and elegance.</p>
<!--more-->

<p>During the promotion of <code>OPF Programming</code>, we found that many C++ users do not
understand how virtual function works, and can not see that <code>Virtual Function</code>
and <code>(*p)-&gt;f(p)</code> have the same root.</p>
<p>This is why we write this article: By explaining the mechanism of
<code>Virtual Function</code> in C++, we hope more people understand the skill of
<code>OPF Programming</code>.</p>
<h1>Example</h1>
<p>A multiple inheritance example (type <code>C</code> inherits functions/methods from both
type <code>A</code> and type <code>B</code>):</p>
<pre><code class="language-c++">class A {
public:
	virtual int af1(int v);
	virtual int af2(int v);
};

class B {
public:
	virtual int bf1(int v);
	virtual int bf2(int v);
	virtual int bf3(int v);
};

class C : public A, public B {
private:
	int i;
	int j;
public:
	int af1(int v) override;
	int bf1(int v) override;
};
</code></pre>
<p>According to the assemly language code generated by compiler, which can be
found at the bottom of this article, we can see the <code>vtable</code> part:</p>
<pre><code class="language-x86asm">vtable for C:
        .quad   0					;;Vtable1
        .quad   typeinfo for C
        .quad   C::af1(int)				;;Entry of vtable1
        .quad   A::af2(int)
        .quad   C::bf1(int)

        .quad   -8					;;Vtable2
        .quad   typeinfo for C
        .quad   non-virtual thunk to C::bf1(int)	;;Entry of vtable2
        .quad   B::bf2(int)
        .quad   B::bf3(int)
</code></pre>
<p>We can see that the start of the vtable is not the entry point of the vtable.
There are 2 fields before function pointers: The offset of the vtable,
the type information.</p>
<p>This type information is the key to support <a href="https://en.wikipedia.org/wiki/Run-time_type_information"><code>RTTI</code>(Run-time type information)</a>.</p>
<p>The way to use <code>vtable</code> can be found in the constructor of type <code>C</code>.</p>
<pre><code class="language-x86asm">	...
        call    A::A() [base object constructor]
	...
        call    B::B() [base object constructor]
        mov     edx, OFFSET FLAT:vtable for C+16	;;Load the address of entry of vtable1
        mov     rax, QWORD PTR [rbp-8]
        mov     QWORD PTR [rax], rdx			;;Write to address of object
        mov     edx, OFFSET FLAT:vtable for C+56	;;Load the address of entry of vtable2
        mov     rax, QWORD PTR [rbp-8]
        mov     QWORD PTR [rax+8], rdx			;;Write to address of object + 8
        nop
        leave
        ret
</code></pre>
<p>We can understand the way <code>virtual function</code> works through 2 examples.</p>
<p>Example 1, accessing <code>C</code> through pointer of type <code>A</code>:</p>
<pre><code class="language-c++">	A *c1 = new C();
	int tmp = c1-&gt;af1(11);
</code></pre>
<pre><code class="language-x86asm">        mov     edi, 24					;;Argument for `new` (the size to allocate)
        call    operator new(unsigned long)		;;Call `new`
        mov     rbx, rax
        mov     QWORD PTR [rbx], 0			;;Initialize the allocated memory with `0`s
        mov     QWORD PTR [rbx+8], 0
        mov     DWORD PTR [rbx+16], 0
        mov     DWORD PTR [rbx+20], 0
        mov     rdi, rbx				;;Prepare arguments for constructor of C
        call    C::C() [complete object constructor]	;;Call constructor
        mov     QWORD PTR [rbp-24], rbx
        mov     rax, QWORD PTR [rbp-24]			;;Load address of `c1` to rax
        mov     rax, QWORD PTR [rax]			;;Indirect memory access to get address of vtable
        mov     rdx, QWORD PTR [rax]			;;Indirect memory access to get address of function
        mov     rax, QWORD PTR [rbp-24]
        mov     esi, 11					;;Prepare the 2nd argument `11`
        mov     rdi, rax				;;Prepare the 1st argument `c1`
        call    rdx					;;Call the function
</code></pre>
<p>According the virtual function invocation, the code is:</p>
<pre><code class="language-c++">c1-&gt;af1(11);
</code></pre>
<p>But actually, through the assembly language code, we know the real code is:</p>
<pre><code class="language-c++">(*c1)-&gt;af1(c1, 11);
</code></pre>
<p>Ignore the unimportant arguments, it&#39;s:</p>
<pre><code class="language-c++">(*p)-&gt;f(p);
</code></pre>
<p>This is why we said:</p>
<blockquote>
<p>The skill of <code>OPF Programming</code>, <code>(*p)-&gt;f(p)</code>, comes from the concept of
<code>Virtual Function</code> in C++.</p>
</blockquote>
<h2><code>C++</code> With Multiple VTable</h2>
<p>The <code>vtable</code> of C++ becomes complex when objects contains more than 1 <code>vtable</code>s.</p>
<p>Example 2, accessing <code>C</code> through pointer of type <code>B</code>:</p>
<pre><code class="language-c++">	B *c2 = new C();
	int tmp = c2-&gt;bf1(22);
</code></pre>
<pre><code class="language-x86asm">        mov     edi, 24					;;Argument for `new` (the size to allocate)
        call    operator new(unsigned long)		;;Call `new`
        mov     rbx, rax
        mov     QWORD PTR [rbx], 0			;;Initialize the allocated memory with `0`s
        mov     QWORD PTR [rbx+8], 0
        mov     DWORD PTR [rbx+16], 0
        mov     DWORD PTR [rbx+20], 0
        mov     rdi, rbx				;;Prepare arguments for constructor of C
        call    C::C() [complete object constructor]	;;Call constructor
        test    rbx, rbx
        je      .L9
        lea     rax, [rbx+8]				;;Adjust the address in rax! Make it point to the pointer to vtable2
        jmp     .L10
.L9:
        mov     eax, 0
.L10:
        mov     QWORD PTR [rbp-32], rax
        mov     rax, QWORD PTR [rbp-32]			;;Like the previous example...
        mov     rax, QWORD PTR [rax]
        mov     rdx, QWORD PTR [rax]
        mov     rax, QWORD PTR [rbp-32]
        mov     esi, 22
        mov     rdi, rax
        call    rdx
</code></pre>
<p><strong>Wait</strong>! the address of the object in this invocation is <strong>wrong</strong>!
it&#39;s <code>address of the object + 8</code> while it should be exactly <code>address of the object</code>.</p>
<p>Because we need the address of the object in the implementation of the
virtual function.</p>
<p>So how to solve this problem?</p>
<p>Look back at the <code>vtable</code>, we can find a weird name
<code>non-virtual thunk to C::bf1(int)</code>.
The assemly language code for this name is:</p>
<pre><code class="language-x86asm">non-virtual thunk to C::bf1(int):
        sub     rdi, 8
        jmp     .LTHUNK0
</code></pre>
<p>What this piece of code is doing is simple:
Subtract 8 from the <code>rdi</code> register (the first argument, address of <code>vtable 2</code>)
to get the address of the object.
After this, it will call the real virtual function <code>C::bf1</code>.</p>
<p>If we merge this subtraction into the previous expression, we can get:</p>
<pre><code class="language-c++">(*p)-&gt;f(p - N);
</code></pre>
<p>This expression also exists in another article
&quot;<a href="/articles/en/multiple-interfaces-in-another-way.html">Another Way For Multiple Interface In C Language</a>&quot;.
Comparing these 2 articles may help a lot.</p>
<h1>The Code</h1>
<pre><code class="language-c++">class A {
public:
	virtual int af1(int v);
	virtual int af2(int v);
};

class B {
public:
	virtual int bf1(int v);
	virtual int bf2(int v);
	virtual int bf3(int v);
};

class C : public A, public B {
private:
	int i;
	int j;
public:
	int af1(int v) override;
	int bf1(int v) override;
};

int C::af1(int v)
{
	return i + v;
}

int C::bf1(int v)
{
	return i + v;
}

int f(void)
{
	int tmp;
	A *c1 = new C();
	tmp = c1-&gt;af1(11);
	B *c2 = new C();
	tmp = c2-&gt;bf1(22);
	return 0;
}
</code></pre>
<p>Assembly code generated by <code>x86-64 gcc 14.1</code>:</p>
<pre><code class="language-x86asm">C::af1(int):
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     DWORD PTR [rbp-12], esi
        mov     rax, QWORD PTR [rbp-8]
        mov     edx, DWORD PTR [rax+16]
        mov     eax, DWORD PTR [rbp-12]
        add     eax, edx
        pop     rbp
        ret
C::bf1(int):
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     DWORD PTR [rbp-12], esi
        mov     rax, QWORD PTR [rbp-8]
        mov     edx, DWORD PTR [rax+16]
        mov     eax, DWORD PTR [rbp-12]
        add     eax, edx
        pop     rbp
        ret
non-virtual thunk to C::bf1(int):
        sub     rdi, 8
        jmp     .LTHUNK0
A::A() [base object constructor]:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     edx, OFFSET FLAT:vtable for A+16
        mov     rax, QWORD PTR [rbp-8]
        mov     QWORD PTR [rax], rdx
        nop
        pop     rbp
        ret
B::B() [base object constructor]:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        mov     edx, OFFSET FLAT:vtable for B+16
        mov     rax, QWORD PTR [rbp-8]
        mov     QWORD PTR [rax], rdx
        nop
        pop     rbp
        ret
C::C() [base object constructor]:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     QWORD PTR [rbp-8], rdi
        mov     rax, QWORD PTR [rbp-8]
        mov     rdi, rax
        call    A::A() [base object constructor]
        mov     rax, QWORD PTR [rbp-8]
        add     rax, 8
        mov     rdi, rax
        call    B::B() [base object constructor]
        mov     edx, OFFSET FLAT:vtable for C+16
        mov     rax, QWORD PTR [rbp-8]
        mov     QWORD PTR [rax], rdx
        mov     edx, OFFSET FLAT:vtable for C+56
        mov     rax, QWORD PTR [rbp-8]
        mov     QWORD PTR [rax+8], rdx
        nop
        leave
        ret
f():
        push    rbp
        mov     rbp, rsp
        push    rbx
        sub     rsp, 40
        mov     edi, 24
        call    operator new(unsigned long)
        mov     rbx, rax
        mov     QWORD PTR [rbx], 0
        mov     QWORD PTR [rbx+8], 0
        mov     DWORD PTR [rbx+16], 0
        mov     DWORD PTR [rbx+20], 0
        mov     rdi, rbx
        call    C::C() [complete object constructor]
        mov     QWORD PTR [rbp-24], rbx
        mov     rax, QWORD PTR [rbp-24]
        mov     rax, QWORD PTR [rax]
        mov     rdx, QWORD PTR [rax]
        mov     rax, QWORD PTR [rbp-24]
        mov     esi, 11
        mov     rdi, rax
        call    rdx
        mov     DWORD PTR [rbp-36], eax
        mov     edi, 24
        call    operator new(unsigned long)
        mov     rbx, rax
        mov     QWORD PTR [rbx], 0
        mov     QWORD PTR [rbx+8], 0
        mov     DWORD PTR [rbx+16], 0
        mov     DWORD PTR [rbx+20], 0
        mov     rdi, rbx
        call    C::C() [complete object constructor]
        test    rbx, rbx
        je      .L9
        lea     rax, [rbx+8]
        jmp     .L10
.L9:
        mov     eax, 0
.L10:
        mov     QWORD PTR [rbp-32], rax
        mov     rax, QWORD PTR [rbp-32]
        mov     rax, QWORD PTR [rax]
        mov     rdx, QWORD PTR [rax]
        mov     rax, QWORD PTR [rbp-32]
        mov     esi, 22
        mov     rdi, rax
        call    rdx
        mov     DWORD PTR [rbp-36], eax
        mov     eax, 0
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
vtable for C:
        .quad   0
        .quad   typeinfo for C
        .quad   C::af1(int)
        .quad   A::af2(int)
        .quad   C::bf1(int)
        .quad   -8
        .quad   typeinfo for C
        .quad   non-virtual thunk to C::bf1(int)
        .quad   B::bf2(int)
        .quad   B::bf3(int)
typeinfo for C:
        .quad   vtable for __cxxabiv1::__vmi_class_type_info+16
        .quad   typeinfo name for C
        .long   0
        .long   2
        .quad   typeinfo for A
        .quad   2
        .quad   typeinfo for B
        .quad   2050
typeinfo name for C:
        .string &quot;1C&quot;
</code></pre>

			<div class="footer">
	All rights reserved. No reproduction or republication without written permission.<br/>
	Email: <a href="mailto:wallacegibbon@aliyun.com">wallacegibbon@aliyun.com</a>
</div>

		</div>
	</div>

	<div class="toolbox-holder">
	<a href="/index.html">âŒ‚</a>
</div>

	<script>
(function() {

function adjust(a) {
	if (/^http/.test(a.getAttribute("href")))
		a.target = "_blank";
}

window.addEventListener("load", function () {
	Array.from(document.querySelectorAll("a"))
		.forEach(adjust);
});

})();
</script>


	<script>
		window.addEventListener('load', function () { hljs.highlightAll(); });
	</script>
</body>
</html>
